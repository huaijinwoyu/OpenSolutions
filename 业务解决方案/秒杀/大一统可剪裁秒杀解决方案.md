# 大一统、可剪裁的秒杀解决方案

- 大一统就是把秒杀系统涉及到的问题都谈谈如何处理
- 可剪裁就是根据自己业务的实际情况取舍其中的步骤

## 随便谈谈，抛砖引玉：）

&emsp;&emsp;所谓秒杀系统就是在非常短的时间内大量用户同时竞买少量商品，最典型的例子就是春节买火车票。

特点：
* 大量用户同时竞买
* 少量商品
  - 超卖问题
* 同时读取（库存量）巨大
  - 多人同时读取同一份数据
* 最终写入（成交量）有限
  - 最终支付问题会有少量用户放弃

假设商品很热，秒杀系统压力巨大，根据上面的特点设计系统，总的设计原则：分批卖。在尽可能的上游拦截（丢弃）多数请求，防止压力最后落到数据库上去

分批卖思路：商品分几次卖，把不同客户分开不同时间段
* 比如每个小时一次

客户端刷新库存量思路：利用缓存长连接或定时刷新，不要搞垮整个系统
* 在浏览器端防止用户重复刷新，但是这个无法防止爬虫等恶意刷新
  - 按钮1秒后才能继续按
  - 
* 恶意快速刷新是不是有相关产品可以直接用，还是说需要自己实现一套
* 服务器端直接缓存商品库存数，绝对不要每次去数据库中取
  - 如果商品库存数不够新没关系，反正下次还会刷新或提交的时候会再次检查

客户端提交订单思路：尽可能拦截处理不了的订单，不要搞垮整个系统
* 在浏览器端拦截订单
  - 随机忽略
    + 随机算法按照概率直接不提交请求，下次请求重新随机
    + 概率：在真正开始前，实际上服务器应该可以统计到目前准备下单用户量，这个数据可以作为一个基础数据，估算一下
  - 加验证码
    + 加上验证码可以极大的降低用户提交订单的频率
* 服务器端
  - 同样需要考虑流氓刷单问题
    + 按照 UID 限制   
  - 剩余的进入秒杀队列
  - 缓存队列容量
    + 如果队列已经太满了，直接放弃剩余请求

* 订单处理
  - 每次从队列中取出一部分进行处理
  - 缓存（redis）商品库存
    + 如果库存已经没了直接忽略后面的订单或等待待支付订单超时
  - 可以考虑让单个实例处理某商品的队列
    + 
  - 每个商品单独一个队列

* 数据库
  - 毫无压力

## FAQ
* Q：何时减库存
  - A：下单时减库存，如果超时了未支付就恢复库存，可以尽可能把超时时间缩短。